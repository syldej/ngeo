{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/format/FeatureHashStyleType.js","webpack:///./src/format/FeatureHash.js","webpack:///./examples/permalink.js"],"names":["webpackJsonpCallback","data","chunkIds","moreModules","executeModules","moduleId","chunkId","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","32","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","getDefault","getModuleExports","object","property","p","jsonpArray","window","oldJsonpFunction","slice","LINE_STRING","POINT","POLYGON","opt_options","olFormatTextFeature","this","options","undefined","accuracy_","accuracy","ACCURACY_","encodeStyles_","encodeStyles","propertiesFunction_","properties","defaultPropertiesFunction_","setStyle_","setStyle","prevX_","prevY_","LegacyProperties_","propertiesType","defaultValues_","defaultValues","olBase","StyleTypes_","LineString","ngeoFormatFeatureHashStyleType","Point","Polygon","MultiLineString","MultiPoint","MultiPolygon","readFeature","readFeatures","readGeometry","writeFeature","writeFeatures","writeGeometry","CHAR64_","feature","getProperties","encodeSignedNumber_","num","signedNum","encodeNumber_","encodedNumber","charAt","styles","geometryType","encodedStyles","styleType","googAsserts","assert","style","fillStyle","getFill","imageStyle","getImage","strokeStyle","getStroke","textStyle","getText","encodeStylePolygon_","encodeStyleLine_","encodeStylePoint_","encodeStyleText_","encodeStyleStroke_","olStyleCircle","radius","getRadius","encodeURIComponent","encodeStyleFill_","opt_propertyName","propertyName","fillColor","getColor","Array","isArray","fillColorRgba","olColor","fillColorHex","ngeoUtils","rgbArrayToHex","strokeColor","strokeColorRgba","strokeColorHex","strokeWidth","getWidth","fontStyle","getFont","font","split","readLineStringGeometry_","text","substring","flatCoordinates","decodeCoordinates_","olGeomLineString","olGeomGeometryLayout","XY","readMultiLineStringGeometry_","ends","lineStrings","ii","olGeomMultiLineString","readPointGeometry_","olGeomPoint","readMultiPointGeometry_","olGeomMultiPoint","readPolygonGeometry_","rings","end","olGeomPolygon","readMultiPolygonGeometry_","endss","polygons","jj","olGeomMultiPolygon","setStyleInFeature_","getStyleProperties_","fontSize","fontColor","pointRadius","olStyleFill","color","olStyleStroke","width","fill","stroke","olStyleText","olStyleStyle","image","setStyleProperties_","geometry","getGeometry","ngeoFormatFeatureProperties","IS_TEXT","parseFloat","indexOf","Math","round","clone","setProperties","castValue_","numProperties","ANGLE","OPACITY","SIZE","STROKE","boolProperties","IS_CIRCLE","IS_RECTANGLE","SHOW_MEASURE","SHOW_LABEL","olArray","parts","part","decodeURIComponent","keyVal","val","writeLineStringGeometry_","assertInstanceof","getFlatCoordinates","stride","getStride","encodeCoordinates_","writeMultiLineStringGeometry_","getEnds","lineStringCount","offset","textArray","join","writePointGeometry_","writeMultiPointGeometry_","encodeRings_","linearRingCount","writePolygonGeometry_","writeMultiPolygonGeometry_","getEndss","polygonCount","GEOMETRY_READERS_","P","L","A","a","GEOMETRY_WRITERS_","opt_flatCoordinates","len","index","b","dx","dy","encodedCoordinates","x","y","floor","readFeatureFromText","splitIndex","geometryText","readGeometryFromText","olFeature","attributesAndStylesText","attributesText","set","stylesText","readFeaturesFromText","_this","features","forEach","geometryReader","writeFeatureText","encodedParts","encodedGeometry","writeGeometryText","encodedProperties","propFunction","getGeometryName","encoded","replace","toString","styleFunction","getStyleFunction","getType","writeFeaturesText","geometryWriter","transformedGeometry","olFormatFeature","angular","ngeoMapModule","ngeoMiscDebounce","ngeoStatemanagerModule","mapComponent","controller","bindings","map","template","component","MapComponentController","ngeoLocation","ngeoDebounce","ngeoLocation_","ngeoDebounce_","$onInit","view","getView","zoom","getParam","center","setCenter","setZoom","updateParams","z","on","e","getCenter","params","getZoom","drawComponent","layer","DrawComponentController","$scope","scope_","featureSeq_","interaction","_this2","vectorSource","getSource","olInteractionDraw","type","source","setActive","addInteraction","ngeoMiscDecorate","fhFormat","ngeoFormatFeatureHash","getFeatures","encodedFeatures","$applyAsync","addFeatures","clearLayer","clear","deleteParam","MainController","olMap","layers","olLayerTile","olSourceOSM","olSourceVector","vectorLayer","olLayerVector","setMap"],"mappings":"aACA,SAAAA,EAAAC,GACA,IAAAC,EAAAD,EAAA,GACA,IAAAE,EAAAF,EAAA,GACA,IAAAG,EAAAH,EAAA,GAIA,IAAAI,EAAAC,EAAAC,EAAA,EAAAC,EAAA,GACA,KAAQD,EAAAL,EAAAO,OAAoBF,IAAA,CAC5BD,EAAAJ,EAAAK,GACA,GAAAG,EAAAJ,GAAA,CACAE,EAAAG,KAAAD,EAAAJ,GAAA,IAEAI,EAAAJ,GAAA,EAEA,IAAAD,KAAAF,EAAA,CACA,GAAAS,OAAAC,UAAAC,eAAAC,KAAAZ,EAAAE,GAAA,CACAW,EAAAX,GAAAF,EAAAE,IAGA,GAAAY,IAAAhB,GAEA,MAAAO,EAAAC,OAAA,CACAD,EAAAU,OAAAV,GAIAW,EAAAR,KAAAS,MAAAD,EAAAf,GAAA,IAGA,OAAAiB,IAEA,SAAAA,IACA,IAAAC,EACA,QAAAf,EAAA,EAAiBA,EAAAY,EAAAV,OAA4BF,IAAA,CAC7C,IAAAgB,EAAAJ,EAAAZ,GACA,IAAAiB,EAAA,KACA,QAAAC,EAAA,EAAkBA,EAAAF,EAAAd,OAA2BgB,IAAA,CAC7C,IAAAC,EAAAH,EAAAE,GACA,GAAAf,EAAAgB,KAAA,EAAAF,EAAA,MAEA,GAAAA,EAAA,CACAL,EAAAQ,OAAApB,IAAA,GACAe,EAAAM,IAAAC,EAAAN,EAAA,KAGA,OAAAD,EAIA,IAAAQ,EAAA,GAKA,IAAApB,EAAA,CACAqB,GAAA,GAGA,IAAAZ,EAAA,GAGA,SAAAS,EAAAvB,GAGA,GAAAyB,EAAAzB,GAAA,CACA,OAAAyB,EAAAzB,GAAA2B,QAGA,IAAAC,EAAAH,EAAAzB,GAAA,CACAE,EAAAF,EACA6B,EAAA,MACAF,QAAA,IAIAhB,EAAAX,GAAAU,KAAAkB,EAAAD,QAAAC,IAAAD,QAAAJ,GAGAK,EAAAC,EAAA,KAGA,OAAAD,EAAAD,QAKAJ,EAAAO,EAAAnB,EAGAY,EAAAQ,EAAAN,EAGAF,EAAAS,EAAA,SAAAL,EAAAM,EAAAC,GACA,IAAAX,EAAAY,EAAAR,EAAAM,GAAA,CACA1B,OAAA6B,eAAAT,EAAAM,EAAA,CAA0CI,WAAA,KAAAC,IAAAJ,MAK1CX,EAAAgB,EAAA,SAAAZ,GACA,UAAAa,SAAA,aAAAA,OAAAC,YAAA,CACAlC,OAAA6B,eAAAT,EAAAa,OAAAC,YAAA,CAAwDC,MAAA,WAExDnC,OAAA6B,eAAAT,EAAA,cAAiDe,MAAA,QAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GACA,GAAAA,EAAA,EAAAF,EAAAnB,EAAAmB,GACA,GAAAE,EAAA,SAAAF,EACA,GAAAE,EAAA,UAAAF,IAAA,UAAAA,KAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAvC,OAAAwC,OAAA,MACAxB,EAAAgB,EAAAO,GACAvC,OAAA6B,eAAAU,EAAA,WAAyCT,WAAA,KAAAK,UACzC,GAAAE,EAAA,UAAAF,GAAA,iBAAAM,KAAAN,EAAAnB,EAAAS,EAAAc,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAtB,GACA,IAAAM,EAAAN,KAAAiB,WACA,SAAAM,IAA2B,OAAAvB,EAAA,YAC3B,SAAAwB,IAAiC,OAAAxB,GACjCL,EAAAS,EAAAE,EAAA,IAAAA,GACA,OAAAA,GAIAX,EAAAY,EAAA,SAAAkB,EAAAC,GAAsD,OAAA/C,OAAAC,UAAAC,eAAAC,KAAA2C,EAAAC,IAGtD/B,EAAAgC,EAAA,GAEA,IAAAC,EAAAC,OAAA,gBAAAA,OAAA,oBACA,IAAAC,EAAAF,EAAAlD,KAAA2C,KAAAO,GACAA,EAAAlD,KAAAX,EACA6D,IAAAG,QACA,QAAAzD,EAAA,EAAgBA,EAAAsD,EAAApD,OAAuBF,IAAAP,EAAA6D,EAAAtD,IACvC,IAAAU,EAAA8C,EAIA5C,EAAAR,KAAA,SAEA,OAAAU,yJC/IA,IAAMW,EAAU,CACdiC,YAAa,aACbC,MAAO,QACPC,QAAS,WAIInC,8OCoCf,IAAMA,EAAU,SAAVA,EAAmBoC,GAEvBC,OAAoBtD,KAAKuD,MAEzB,IAAMC,EAAUH,IAAgBI,UAAYJ,EAAc,GAM1DE,KAAKG,UAAYF,EAAQG,WAAaF,UACpCD,EAAQG,SAAW1C,EAAQ2C,UAM7BL,KAAKM,cAAgBL,EAAQM,eAAiBL,UAC5CD,EAAQM,aAAe,KAMzBP,KAAKQ,oBAAsBP,EAAQQ,aAAeP,UAChDD,EAAQQ,WAAa/C,EAAQgD,2BAM/BV,KAAKW,UAAYV,EAAQW,WAAaV,UAAYD,EAAQW,SAAW,KAMrEZ,KAAKa,OAAS,EAMdb,KAAKc,OAAS,EAMdpD,EAAQqD,kBAAqBd,EAAQe,iBAAmBd,WAAcD,EAAQe,eAM9EhB,KAAKiB,eAAiBhB,EAAQiB,gBAAkBhB,UAAYD,EAAQiB,cAAgB,IAItFC,OAAgBzD,EAASqC,QAOzBrC,EAAQ0D,YAAc,CACpBC,WAAcC,EAA+B3B,YAC7C4B,MAASD,EAA+B1B,MACxC4B,QAAWF,EAA+BzB,QAC1C4B,gBAAmBH,EAA+B3B,YAClD+B,WAAcJ,EAA+B1B,MAC7C+B,aAAgBL,EAA+BzB,SAOjDnC,EAAQqD,kBAAoB,GAM5BrD,EAAQnB,UAAUqF,YAMlBlE,EAAQnB,UAAUsF,aAMlBnE,EAAQnB,UAAUuF,aAMlBpE,EAAQnB,UAAUwF,aAMlBrE,EAAQnB,UAAUyF,cAMlBtE,EAAQnB,UAAU0F,cAUlBvE,EAAQwE,QACJ,mEAOJxE,EAAQ2C,UAAY,GAUpB3C,EAAQgD,2BAA6B,SAASyB,GAC5C,OAAOA,EAAQC,iBAUjB1E,EAAQ2E,oBAAsB,SAASC,GACrC,IAAIC,EAAYD,GAAO,EACvB,GAAIA,EAAM,EAAG,CACXC,GAAcA,EAEhB,OAAO7E,EAAQ8E,cAAcD,IAU/B7E,EAAQ8E,cAAgB,SAASF,GAC/B,IAAIG,EAAgB,GACpB,MAAOH,GAAO,GAAM,CAClBG,GAAiB/E,EAAQwE,QAAQQ,OAC/B,GAAQJ,EAAM,IAChBA,IAAQ,EAEVG,GAAiB/E,EAAQwE,QAAQQ,OAAOJ,GACxC,OAAOG,GAaT/E,EAAQ4C,cAAgB,SAASqC,EAAQC,EAAcC,GACrD,IAAMC,EAAYpF,EAAQ0D,YAAYwB,GACtCG,OAAYC,OAAOF,IAAc5C,WACjC,IAAK,IAAIjE,EAAI,EAAGA,EAAI0G,EAAOxG,SAAUF,EAAG,CACtC,IAAMgH,EAAQN,EAAO1G,GACrB,IAAMiH,EAAYD,EAAME,UACxB,IAAMC,EAAaH,EAAMI,WACzB,IAAMC,EAAcL,EAAMM,YAC1B,IAAMC,EAAYP,EAAMQ,UACxB,GAAIX,GAAaxB,EAA+BzB,QAAS,CACvD,GAAIqD,IAAc,KAAM,CACtBxF,EAAQgG,oBACNR,EAAWI,EAAaT,SAEvB,GAAIC,GAAaxB,EAA+B3B,YAAa,CAClE,GAAI2D,IAAgB,KAAM,CACxB5F,EAAQiG,iBAAiBL,EAAaT,SAEnC,GAAIC,GAAaxB,EAA+B1B,MAAO,CAC5D,GAAIwD,IAAe,KAAM,CACvB1F,EAAQkG,kBAAkBR,EAAYP,IAG1C,GAAIW,IAAc,KAAM,CACtB9F,EAAQmG,iBAAiBL,EAAWX,MAa1CnF,EAAQiG,iBAAmB,SAASL,EAAaT,GAC/CnF,EAAQoG,mBAAmBR,EAAaT,IAW1CnF,EAAQkG,kBAAoB,SAASR,EAAYP,GAC/C,GAAIO,aAAsBW,OAAe,CACvC,IAAMC,EAASZ,EAAWa,YAC1B,GAAIpB,EAAc1G,OAAS,EAAG,CAC5B0G,EAAcxG,KAAK,KAErBwG,EAAcxG,KAAK6H,mBAAkB,eAAgBF,IACrD,IAAMd,EAAYE,EAAWD,UAC7B,GAAID,IAAc,KAAM,CACtBxF,EAAQyG,iBAAiBjB,EAAWL,GAEtC,IAAMS,EAAcF,EAAWG,YAC/B,GAAID,IAAgB,KAAM,CACxB5F,EAAQoG,mBAAmBR,EAAaT,MAe9CnF,EAAQgG,oBAAsB,SAASR,EAAWI,EAAaT,GAC7DnF,EAAQyG,iBAAiBjB,EAAWL,GACpC,GAAIS,IAAgB,KAAM,CACxB5F,EAAQoG,mBAAmBR,EAAaT,KAc5CnF,EAAQyG,iBAAmB,SAASjB,EAAWL,EAAeuB,GAC5D,IAAMC,EAAeD,IAAqBlE,UACxCkE,EAAmB,YACrB,IAAME,EAAYpB,EAAUqB,WAC5B,GAAID,IAAc,KAAM,CACtBvB,OAAYC,OAAOwB,MAAMC,QAAQH,GAAY,+BAC7C,IAAMI,EAAgBC,OAAgBL,GACtCvB,OAAYC,OAAOwB,MAAMC,QAAQC,GAAgB,+BACjD,IAAME,EAAeC,OAAUC,cAAcJ,GAC7C,GAAI7B,EAAc1G,OAAS,EAAG,CAC5B0G,EAAcxG,KAAK,KAErBwG,EAAcxG,KACZ6H,mBAAsBG,EAAJ,IAAoBO,MAY5ClH,EAAQoG,mBAAqB,SAASR,EAAaT,GACjD,IAAMkC,EAAczB,EAAYiB,WAChC,GAAIQ,IAAgB,KAAM,CACxBhC,OAAYC,OAAOwB,MAAMC,QAAQM,IACjC,IAAMC,EAAkBL,OAAgBI,GACxChC,OAAYC,OAAOwB,MAAMC,QAAQO,GAAkB,iCACnD,IAAMC,EAAiBJ,OAAUC,cAAcE,GAC/C,GAAInC,EAAc1G,OAAS,EAAG,CAC5B0G,EAAcxG,KAAK,KAErBwG,EAAcxG,KAAK6H,mBAAkB,eAAgBe,IAEvD,IAAMC,EAAc5B,EAAY6B,WAChC,GAAID,IAAgBhF,UAAW,CAC7B,GAAI2C,EAAc1G,OAAS,EAAG,CAC5B0G,EAAcxG,KAAK,KAErBwG,EAAcxG,KAAK6H,mBAAkB,eAAgBgB,MAYzDxH,EAAQmG,iBAAmB,SAASL,EAAWX,GAC7C,IAAMuC,EAAY5B,EAAU6B,UAC5B,GAAID,IAAclF,UAAW,CAC3B,IAAMoF,EAAOF,EAAUG,MAAM,KAC7B,GAAID,EAAKnJ,QAAU,EAAG,CACpB,GAAI0G,EAAc1G,OAAS,EAAG,CAC5B0G,EAAcxG,KAAK,KAErBwG,EAAcxG,KAAK6H,mBAAkB,YAAaoB,EAAK,MAG3D,IAAMpC,EAAYM,EAAUL,UAC5B,GAAID,IAAc,KAAM,CACtBxF,EAAQyG,iBACNjB,EAAWL,EAAe,eAahCnF,EAAQ8H,wBAA0B,SAASC,GACzC1C,OAAYC,OAAOyC,EAAKC,UAAU,EAAG,KAAO,MAC5C3C,OAAYC,OAAOyC,EAAKA,EAAKtJ,OAAS,IAAM,KAC5CsJ,EAAOA,EAAKC,UAAU,EAAGD,EAAKtJ,OAAS,GACvC,IAAMwJ,EAAkB3F,KAAK4F,mBAAmBH,GAChD,OAAO,IAAII,OAAiBF,EAAiBG,OAAqBC,KAYpErI,EAAQsI,6BAA+B,SAASP,GAC9C1C,OAAYC,OAAOyC,EAAKC,UAAU,EAAG,KAAO,MAC5C3C,OAAYC,OAAOyC,EAAKA,EAAKtJ,OAAS,IAAM,KAC5CsJ,EAAOA,EAAKC,UAAU,EAAGD,EAAKtJ,OAAS,GACvC,IAAIwJ,EAAkB,GACtB,IAAMM,EAAO,GACb,IAAMC,EAAcT,EAAKF,MAAM,KAC/B,IAAK,IAAItJ,EAAI,EAAGkK,EAAKD,EAAY/J,OAAQF,EAAIkK,IAAMlK,EAAG,CACpD0J,EAAkB3F,KAAK4F,mBAAmBM,EAAYjK,GAAI0J,GAC1DM,EAAKhK,GAAK0J,EAAgBxJ,OAE5B,OAAO,IAAIiK,OAAsBT,EAAiBG,OAAqBC,GAAIE,IAY7EvI,EAAQ2I,mBAAqB,SAASZ,GACpC1C,OAAYC,OAAOyC,EAAKC,UAAU,EAAG,KAAO,MAC5C3C,OAAYC,OAAOyC,EAAKA,EAAKtJ,OAAS,IAAM,KAC5CsJ,EAAOA,EAAKC,UAAU,EAAGD,EAAKtJ,OAAS,GACvC,IAAMwJ,EAAkB3F,KAAK4F,mBAAmBH,GAChD1C,OAAYC,OAAO2C,EAAgBxJ,SAAW,GAC9C,OAAO,IAAImK,OAAYX,EAAiBG,OAAqBC,KAY/DrI,EAAQ6I,wBAA0B,SAASd,GACzC1C,OAAYC,OAAOyC,EAAKC,UAAU,EAAG,KAAO,MAC5C3C,OAAYC,OAAOyC,EAAKA,EAAKtJ,OAAS,IAAM,KAC5CsJ,EAAOA,EAAKC,UAAU,EAAGD,EAAKtJ,OAAS,GACvC,IAAMwJ,EAAkB3F,KAAK4F,mBAAmBH,GAChD,OAAO,IAAIe,OAAiBb,EAAiBG,OAAqBC,KAYpErI,EAAQ+I,qBAAuB,SAAShB,GACtC1C,OAAYC,OAAOyC,EAAKC,UAAU,EAAG,KAAO,MAC5C3C,OAAYC,OAAOyC,EAAKA,EAAKtJ,OAAS,IAAM,KAC5CsJ,EAAOA,EAAKC,UAAU,EAAGD,EAAKtJ,OAAS,GACvC,IAAIwJ,EAAkB,GACtB,IAAMM,EAAO,GACb,IAAMS,EAAQjB,EAAKF,MAAM,KACzB,IAAK,IAAItJ,EAAI,EAAGkK,EAAKO,EAAMvK,OAAQF,EAAIkK,IAAMlK,EAAG,CAC9C0J,EAAkB3F,KAAK4F,mBAAmBc,EAAMzK,GAAI0J,GACpD,IAAIgB,EAAMhB,EAAgBxJ,OAC1B,GAAIF,IAAM,EAAG,CACX0J,EAAgBgB,KAAShB,EAAgB,GACzCA,EAAgBgB,KAAShB,EAAgB,OACpC,CACLA,EAAgBgB,KAAShB,EAAgBM,EAAKhK,EAAI,IAClD0J,EAAgBgB,KAAShB,EAAgBM,EAAKhK,EAAI,GAAK,GAEzDgK,EAAKhK,GAAK0K,EAEZ,OAAO,IAAIC,OAAcjB,EAAiBG,OAAqBC,GAAIE,IAYrEvI,EAAQmJ,0BAA4B,SAASpB,GAC3C1C,OAAYC,OAAOyC,EAAKC,UAAU,EAAG,KAAO,MAC5C3C,OAAYC,OAAOyC,EAAKA,EAAKtJ,OAAS,IAAM,KAC5CsJ,EAAOA,EAAKC,UAAU,EAAGD,EAAKtJ,OAAS,GACvC,IAAIwJ,EAAkB,GACtB,IAAMmB,EAAQ,GACd,IAAMC,EAAWtB,EAAKF,MAAM,MAC5B,IAAK,IAAItJ,EAAI,EAAGkK,EAAKY,EAAS5K,OAAQF,EAAIkK,IAAMlK,EAAG,CACjD,IAAMyK,EAAQK,EAAS9K,GAAGsJ,MAAM,KAChC,IAAMU,EAAOa,EAAM7K,GAAK,GACxB,IAAK,IAAIkB,EAAI,EAAG6J,EAAKN,EAAMvK,OAAQgB,EAAI6J,IAAM7J,EAAG,CAC9CwI,EAAkB3F,KAAK4F,mBAAmBc,EAAMvJ,GAAIwI,GACpD,IAAIgB,EAAMhB,EAAgBxJ,OAC1B,GAAIgB,IAAM,EAAG,CACXwI,EAAgBgB,KAAShB,EAAgB,GACzCA,EAAgBgB,KAAShB,EAAgB,OACpC,CACLA,EAAgBgB,KAAShB,EAAgBM,EAAK9I,EAAI,IAClDwI,EAAgBgB,KAAShB,EAAgBM,EAAK9I,EAAI,GAAK,GAEzD8I,EAAK9I,GAAKwJ,GAGd,OAAO,IAAIM,OAAmBtB,EAAiBG,OAAqBC,GAAIe,IAc1EpJ,EAAQwJ,mBAAqB,SAASzB,EAAMtD,GAC1C,GAAIsD,GAAQ,GAAI,CACd,OAEF,IAAMhF,EAAa/C,EAAQyJ,oBAAoB1B,EAAMtD,GACrD,IAAMmC,EAAY7D,EAAW,aAC7B,IAAM2G,EAAW3G,EAAW,YAC5B,IAAM4G,EAAY5G,EAAW,aAC7B,IAAM6G,EAAc7G,EAAW,eAC/B,IAAMsE,EAActE,EAAW,eAC/B,IAAMyE,EAAczE,EAAW,eAE/B,IAAIyC,EAAY,KAChB,GAAIoB,IAAcpE,UAAW,CAC3BgD,EAAY,IAAIqE,OAAY,CAC1BC,MAA4ClD,IAGhD,IAAIhB,EAAc,KAClB,GAAIyB,IAAgB7E,WAAagF,IAAgBhF,UAAW,CAC1DoD,EAAc,IAAImE,OAAc,CAC9BD,MAA4CzC,EAC5C2C,MAA8BxC,IAGlC,IAAI9B,EAAa,KACjB,GAAIkE,IAAgBpH,UAAW,CAC7BkD,EAAa,IAAIW,OAAc,CAC7BC,OAA+BsD,EAC/BK,KAAMzE,EACN0E,OAAQtE,IAEVJ,EAAYI,EAAc,KAE5B,IAAIE,EAAY,KAChB,GAAI4D,IAAalH,WAAamH,IAAcnH,UAAW,CACrDsD,EAAY,IAAIqE,OAAY,CAC1BvC,KAAS8B,EAAL,cACJO,KAAM,IAAIJ,OAAY,CACpBC,MAA4CH,MAIlD,IAAMpE,EAAQ,IAAI6E,OAAa,CAC7BH,KAAMzE,EACN6E,MAAO3E,EACPwE,OAAQtE,EACRmC,KAAMjC,IAERrB,EAAQvB,SAASqC,IAYnBvF,EAAQsK,oBAAsB,SAASvC,EAAMtD,GAE3C,IAAM1B,EAAa/C,EAAQyJ,oBAAoB1B,EAAMtD,GACrD,IAAM8F,EAAW9F,EAAQ+F,cAGzB,GAAID,aAAoB3B,OAAa,CACnC,GAAI7F,EAAW,YACXA,EAAW0H,OAA4BC,SAAU,QAC5C3H,EAAW,sBACXA,EAAW,iBACb,QACEA,EAAW,oBACXA,EAAW,iBAEf,QACEA,EAAW,aAElB,GAAIwH,aAAoBpC,OAAkB,QACjCpF,EAAW,oBACXA,EAAW,gBAKtB,GAAIA,EAAW,YAAa,CAC1B,IAAI2G,EAAWiB,WAAW5H,EAAW,aACrC,GAAIA,EAAW,YAAY6H,QAAQ,SAAW,EAAG,CAC/ClB,EAAWmB,KAAKC,MAAMpB,EAAW,UAEnC3G,EAAW,YAAc2G,EAI3B,IAAMqB,EAAQ,GACd,IAAK,IAAM1J,KAAO0B,EAAY,CAC5B,IAAMhC,EAAQgC,EAAW1B,GACzB,GAAIrB,EAAQqD,kBAAkBhC,GAAM,CAClC0J,EAAM/K,EAAQqD,kBAAkBhC,IAAQN,MACnC,CACLgK,EAAM1J,GAAON,GAIjB0D,EAAQuG,cAAcD,IAWxB/K,EAAQiL,WAAa,SAAS5J,EAAKN,GACjC,IAAMmK,EAAgB,CACpBT,OAA4BU,MAC5BV,OAA4BW,QAC5BX,OAA4BY,KAC5BZ,OAA4Ba,OAC5B,cACA,eAEF,IAAMC,EAAiB,CACrBd,OAA4Be,UAC5Bf,OAA4BgB,aAC5BhB,OAA4BC,QAC5BD,OAA4BiB,aAC5BjB,OAA4BkB,WAC5B,WACA,cACA,UACA,cACA,aAGF,GAAIC,OAAiBV,EAAe7J,GAAM,CACxC,OAAQN,OACH,GAAI6K,OAAiBL,EAAgBlK,GAAM,CAChD,OAAQN,IAAU,OAAU,KAAO,UAC9B,CACL,OAAOA,IAgBXf,EAAQyJ,oBAAsB,SAAS1B,EAAMtD,GAC3C,IAAMoH,EAAQ9D,EAAKF,MAAM,KACzB,IAAM9E,EAAa,GAEnB,IAAK,IAAIxE,EAAI,EAAGA,EAAIsN,EAAMpN,SAAUF,EAAG,CACrC,IAAMuN,EAAOC,mBAAmBF,EAAMtN,IACtC,IAAMyN,EAASF,EAAKjE,MAAM,KAC1BxC,OAAYC,OAAO0G,EAAOvN,SAAW,GACrC,IAAM4C,EAAM2K,EAAO,GACnB,IAAMC,EAAMD,EAAO,GAEnBjJ,EAAW1B,GAAOrB,EAAQiL,WAAW5J,EAAK4K,GAG5C,OAAOlJ,GAYT/C,EAAQkM,yBAA2B,SAAS3B,GAC1ClF,OAAY8G,iBAAiB5B,EAAUpC,QACvC,IAAMF,EAAkBsC,EAAS6B,qBACjC,IAAMC,EAAS9B,EAAS+B,YACxB,IAAMrD,EAAMhB,EAAgBxJ,OAC5B,WAAY6D,KAAKiK,mBAAmBtE,EAAiBoE,EAAQ,EAAGpD,GAAhE,KAYFjJ,EAAQwM,8BAAgC,SAASjC,GAC/ClF,OAAY8G,iBAAiB5B,EAAU7B,QACvC,IAAMH,EAAOgC,EAASkC,UACtB,IAAMC,EAAkBnE,EAAK9J,OAC7B,IAAMwJ,EAAkBsC,EAAS6B,qBACjC,IAAMC,EAAS9B,EAAS+B,YACxB,IAAIK,EAAS,EACb,IAAMC,EAAY,CAAC,MACnB,IAAK,IAAIrO,EAAI,EAAGA,EAAImO,IAAmBnO,EAAG,CACxC,IAAM0K,EAAMV,EAAKhK,GACjB,IAAMwJ,EAAOzF,KAAKiK,mBAAmBtE,EAAiBoE,EAAQM,EAAQ1D,GACtE,GAAI1K,IAAM,EAAG,CACXqO,EAAUjO,KAAK,KAEjBiO,EAAUjO,KAAKoJ,GACf4E,EAAS1D,EAEX2D,EAAUjO,KAAK,KACf,OAAOiO,EAAUC,KAAK,KAYxB7M,EAAQ8M,oBAAsB,SAASvC,GACrClF,OAAY8G,iBAAiB5B,EAAU3B,QACvC,IAAMX,EAAkBsC,EAAS6B,qBACjC,IAAMC,EAAS9B,EAAS+B,YACxB,IAAMrD,EAAMhB,EAAgBxJ,OAC5B,WAAY6D,KAAKiK,mBAAmBtE,EAAiBoE,EAAQ,EAAGpD,GAAhE,KAYFjJ,EAAQ+M,yBAA2B,SAASxC,GAC1ClF,OAAY8G,iBAAiB5B,EAAUzB,QACvC,IAAMb,EAAkBsC,EAAS6B,qBACjC,IAAMC,EAAS9B,EAAS+B,YACxB,IAAMrD,EAAMhB,EAAgBxJ,OAC5B,WAAY6D,KAAKiK,mBAAmBtE,EAAiBoE,EAAQ,EAAGpD,GAAhE,KAeFjJ,EAAQgN,aAAe,SAAS/E,EAAiBoE,EAAQM,EAAQpE,EAAMqE,GACrE,IAAMK,EAAkB1E,EAAK9J,OAC7B,IAAK,IAAIF,EAAI,EAAGA,EAAI0O,IAAmB1O,EAAG,CAExC,IAAM0K,EAAMV,EAAKhK,GAAK8N,EACtB,IAAMtE,EAAOzF,KAAKiK,mBAAmBtE,EAAiBoE,EAAQM,EAAQ1D,GACtE,GAAI1K,IAAM,EAAG,CACXqO,EAAUjO,KAAK,KAEjBiO,EAAUjO,KAAKoJ,GACf4E,EAASpE,EAAKhK,GAEhB,OAAOoO,GAYT3M,EAAQkN,sBAAwB,SAAS3C,GACvClF,OAAY8G,iBAAiB5B,EAAUrB,QACvC,IAAMjB,EAAkBsC,EAAS6B,qBACjC,IAAMC,EAAS9B,EAAS+B,YACxB,IAAM/D,EAAOgC,EAASkC,UACtB,IAAME,EAAS,EACf,IAAMC,EAAY,CAAC,MACnB5M,EAAQgN,aAAajO,KAAKuD,KACxB2F,EAAiBoE,EAAQM,EAAQpE,EAAMqE,GACzCA,EAAUjO,KAAK,KACf,OAAOiO,EAAUC,KAAK,KAYxB7M,EAAQmN,2BAA6B,SAAS5C,GAC5ClF,OAAY8G,iBAAiB5B,EAAUhB,QACvC,IAAMtB,EAAkBsC,EAAS6B,qBACjC,IAAMC,EAAS9B,EAAS+B,YACxB,IAAMlD,EAAQmB,EAAS6C,WACvB,IAAMC,EAAejE,EAAM3K,OAC3B,IAAIkO,EAAS,EACb,IAAMC,EAAY,CAAC,KACnB,IAAK,IAAIrO,EAAI,EAAGA,EAAI8O,IAAgB9O,EAAG,CACrC,IAAMgK,EAAOa,EAAM7K,GACnBqO,EAAUjO,KAAK,KACfgO,EAAS3M,EAAQgN,aAAajO,KAAKuD,KACjC2F,EAAiBoE,EAAQM,EAAQpE,EAAMqE,GACzCA,EAAUjO,KAAK,KAEjB,OAAOiO,EAAUC,KAAK,KASxB7M,EAAQsN,kBAAoB,CAC1BC,EAAKvN,EAAQ6I,wBACb2E,EAAKxN,EAAQsI,6BACbmF,EAAKzN,EAAQmJ,0BACbjJ,EAAKF,EAAQ8H,wBACblG,EAAK5B,EAAQ2I,mBACb+E,EAAK1N,EAAQ+I,sBASf/I,EAAQ2N,kBAAoB,CAC1B5J,gBAAmB/D,EAAQwM,8BAC3BxI,WAAchE,EAAQ+M,yBACtB9I,aAAgBjE,EAAQmN,2BACxBxJ,WAAc3D,EAAQkM,yBACtBrI,MAAS7D,EAAQ8M,oBACjBhJ,QAAW9D,EAAQkN,uBAcrBlN,EAAQnB,UAAUqJ,mBAAqB,SAASH,EAAM6F,GACpD,IAAMC,EAAM9F,EAAKtJ,OACjB,IAAIqP,EAAQ,EACZ,IAAM7F,EAAkB2F,IAAwBpL,UAC9CoL,EAAsB,GACxB,IAAIrP,EAAI0J,EAAgBxJ,OACxB,MAAOqP,EAAQD,EAAK,CAClB,IAAIE,OAAC,EACL,IAAI7O,EAAQ,EACZ,IAAII,EAAS,EACb,EAAG,CACDyO,EAAI/N,EAAQwE,QAAQoG,QAAQ7C,EAAK/C,OAAO8I,MACxCxO,IAAWyO,EAAI,KAAS7O,EACxBA,GAAS,QACF6O,GAAK,IACd,IAAMC,EAAO1O,EAAS,IAAOA,GAAU,GAAMA,GAAU,EACvDgD,KAAKa,QAAU6K,EACf9O,EAAQ,EACRI,EAAS,EACT,EAAG,CACDyO,EAAI/N,EAAQwE,QAAQoG,QAAQ7C,EAAK/C,OAAO8I,MACxCxO,IAAWyO,EAAI,KAAS7O,EACxBA,GAAS,QACF6O,GAAK,IACd,IAAME,EAAO3O,EAAS,IAAOA,GAAU,GAAMA,GAAU,EACvDgD,KAAKc,QAAU6K,EACfhG,EAAgB1J,KAAO+D,KAAKa,OAASb,KAAKG,UAC1CwF,EAAgB1J,KAAO+D,KAAKc,OAASd,KAAKG,UAE5C,OAAOwF,GAeTjI,EAAQnB,UAAU0N,mBAAqB,SAAStE,EAAiBoE,EAAQM,EAAQ1D,GAC/E,IAAIiF,EAAqB,GACzB,IAAK,IAAI3P,EAAIoO,EAAQpO,EAAI0K,EAAK1K,GAAK8N,EAAQ,CACzC,IAAI8B,EAAIlG,EAAgB1J,GACxB,IAAI6P,EAAInG,EAAgB1J,EAAI,GAC5B4P,EAAItD,KAAKwD,MAAMF,EAAI7L,KAAKG,WACxB2L,EAAIvD,KAAKwD,MAAMD,EAAI9L,KAAKG,WACxB,IAAMuL,EAAKG,EAAI7L,KAAKa,OACpB,IAAM8K,EAAKG,EAAI9L,KAAKc,OACpBd,KAAKa,OAASgL,EACd7L,KAAKc,OAASgL,EACdF,GAAsBlO,EAAQ2E,oBAAoBqJ,GAC9ChO,EAAQ2E,oBAAoBsJ,GAElC,OAAOC,GAYTlO,EAAQnB,UAAUyP,oBAAsB,SAASvG,EAAM3F,GACrDiD,OAAYC,OAAOyC,EAAKtJ,OAAS,GACjC4G,OAAYC,OAAOyC,EAAK,KAAO,KAC/B1C,OAAYC,OAAOyC,EAAKA,EAAKtJ,OAAS,KAAO,KAC7C,IAAI8P,EAAaxG,EAAK6C,QAAQ,KAC9B,IAAM4D,EAAeD,GAAc,EAC9BxG,EAAKC,UAAU,EAAGuG,GADF,IACmBxG,EACxC,IAAMwC,EAAWjI,KAAKmM,qBAAqBD,EAAcpM,GACzD,IAAMqC,EAAU,IAAIiK,OAAUnE,GAC9B,GAAIgE,GAAc,EAAG,CACnB,IAAMI,EAA0B5G,EAAKC,UACnCuG,EAAa,EAAGxG,EAAKtJ,OAAS,GAChC8P,EAAaI,EAAwB/D,QAAQ,KAC7C,IAAMgE,EAAiBL,GAAc,EACnCI,EAAwB3G,UAAU,EAAGuG,GACrCI,EACF,GAAIC,GAAkB,GAAI,CACxB,IAAM/C,EAAQ+C,EAAe/G,MAAM,KACnC,IAAK,IAAItJ,EAAI,EAAGA,EAAIsN,EAAMpN,SAAUF,EAAG,CACrC,IAAMuN,EAAOC,mBAAmBF,EAAMtN,IACtC,IAAMyN,EAASF,EAAKjE,MAAM,KAC1BxC,OAAYC,OAAO0G,EAAOvN,SAAW,GACrC,IAAI4C,EAAM2K,EAAO,GACjB,IAAMjL,EAAQiL,EAAO,GACrB,IAAK1J,KAAKW,WAAajD,EAAQqD,kBAAkBhC,GAAM,CACrDA,EAAMrB,EAAQqD,kBAAkBhC,GAElCoD,EAAQoK,IAAIxN,EAAKrB,EAAQiL,WAAW5J,EAAKN,KAG7C,GAAIwN,GAAc,EAAG,CACnB,IAAMO,EAAaH,EAAwB3G,UAAUuG,EAAa,GAClE,GAAIjM,KAAKW,UAAW,CAClBjD,EAAQwJ,mBAAmBsF,EAAYrK,OAClC,CACLzE,EAAQsK,oBAAoBwE,EAAYrK,KAI9C,OAAOA,GAYTzE,EAAQnB,UAAUkQ,qBAAuB,SAAShH,EAAM3F,GAAa,IAAA4M,EAAA1M,KACnE+C,OAAYC,OAAOyC,EAAK,KAAO,KAC/BzF,KAAKa,OAAS,EACdb,KAAKc,OAAS,EAEd,IAAM6L,EAAW,GACjBlH,EAAOA,EAAKC,UAAU,GACtB,MAAOD,EAAKtJ,OAAS,EAAG,CACtB,IAAMqP,EAAQ/F,EAAK6C,QAAQ,KAC3BvF,OAAYC,OAAOwI,GAAS,GAC5B,IAAMrJ,EAAUnC,KAAKgM,oBACnBvG,EAAKC,UAAU,EAAG8F,EAAQ,GAAI1L,GAChC6M,EAAStQ,KAAK8F,GACdsD,EAAOA,EAAKC,UAAU8F,EAAQ,GAIhCmB,EAASC,QAAQ,SAACzK,GAChB,IAAK,IAAMpD,KAAO2N,EAAKzL,eAAgB,CACrC,IAAM5B,EAAW3B,EAAQqD,kBAAkBhC,GAC3C,GAAIoD,EAAQ9D,IAAIgB,KAAca,UAAW,CACvCiC,EAAQoK,IAAIlN,EAAUqN,EAAKzL,eAAelC,GAAKtC,KAAK,KAAM0F,QAIhE,OAAOwK,GAYTjP,EAAQnB,UAAU4P,qBAAuB,SAAS1G,EAAM3F,GACtD,IAAM+M,EAAiBnP,EAAQsN,kBAAkBvF,EAAK,IACtD1C,OAAYC,OAAO6J,IAAmB3M,WACtC,OAAO2M,EAAepQ,KAAKuD,KAAMyF,IAYnC/H,EAAQnB,UAAUuQ,iBAAmB,SAAS3K,EAASrC,GACrD,IAAoCiN,EAAe,GAInD,IAAIC,EAAkB,GACtB,IAAM/E,EAAW9F,EAAQ+F,cACzB,GAAID,EAAU,CACZ+E,EAAkBhN,KAAKiN,kBAAkBhF,EAAUnI,GAGrD,GAAIkN,EAAgB7Q,OAAS,EAAG,CAE9B4G,OAAYC,OAAOgK,EAAgBA,EAAgB7Q,OAAS,KAAO,KACnE6Q,EAAkBA,EAAgBtH,UAAU,EAAGsH,EAAgB7Q,OAAS,GACxE4Q,EAAa1Q,KAAK2Q,GAKpB,IAAoCE,EAAoB,GACxD,IAAMC,EAAenN,KAAKQ,oBAAoB2B,GAC9C,IAAK,IAAMpD,KAAOoO,EAAc,CAC9B,IAAM1O,EAAQ0O,EAAapO,GAC3B,GAAIN,IAAUyB,WAAazB,IAAU,MAAQM,IAAQoD,EAAQiL,kBAAmB,CAC9E,GAAIF,EAAkB/Q,SAAW,EAAG,CAClC+Q,EAAkB7Q,KAAK,KAEzB,IAAMgR,EAAUnJ,mBACXnF,EAAIuO,QAAQ,UAAW,KADM,IAE9B7O,EAAM8O,WAAWD,QAAQ,UAAW,MACxCJ,EAAkB7Q,KAAKgR,IAI3B,GAAIH,EAAkB/Q,OAAS,EAAG,CAChC4Q,EAAa1Q,KAAK,KAClBmI,MAAMjI,UAAUF,KAAKS,MAAMiQ,EAAcG,GAK3C,GAAIlN,KAAKM,cAAe,CACtB,IAAMkN,EAAgBrL,EAAQsL,mBAC9B,GAAID,IAAkBtN,UAAW,CAC/B,IAAIyC,EAAS6K,EAAc/Q,KAAK0F,EAAS,GACzC,GAAIQ,IAAW,KAAM,CACnB,IAAME,EAAgB,GACtBF,EAAS6B,MAAMC,QAAQ9B,GAAUA,EAAS,CAACA,GAC3CjF,EAAQ4C,cACNqC,EAAQsF,EAASyF,UAAW7K,GAC9B,GAAIA,EAAc1G,OAAS,EAAG,CAC5B4Q,EAAa1Q,KAAK,KAClBmI,MAAMjI,UAAUF,KAAKS,MAAMiQ,EAAclK,MAQjDkK,EAAa1Q,KAAK,KAClB,OAAO0Q,EAAaxC,KAAK,KAY3B7M,EAAQnB,UAAUoR,kBAAoB,SAAShB,EAAU7M,GACvDE,KAAKa,OAAS,EACdb,KAAKc,OAAS,EACd,IAAMwJ,EAAY,GAClB,GAAIqC,EAASxQ,OAAS,EAAG,CACvBmO,EAAUjO,KAAK,KACf,IAAK,IAAIJ,EAAI,EAAGkK,EAAKwG,EAASxQ,OAAQF,EAAIkK,IAAMlK,EAAG,CACjDqO,EAAUjO,KAAK2D,KAAK8M,iBAAiBH,EAAS1Q,GAAI6D,KAGtD,OAAOwK,EAAUC,KAAK,KAYxB7M,EAAQnB,UAAU0Q,kBAAoB,SAAShF,EAAUnI,GACvD,IAAM8N,EAAiBlQ,EAAQ2N,kBAC7BpD,EAASyF,WACX3K,OAAYC,OAAO4K,IAAmB1N,WACtC,IAAM2N,EACDC,OAAqC7F,EAAU,KAAMnI,GAC1D,OAAO8N,EAAenR,KAAKuD,KAAM6N,IAIpBnQ,kICxrCf,IAAMA,EAAU,GAoBhBA,EAAQC,OAASoQ,QAAQpQ,OAAO,MAAO,CACrC,UACAqQ,OAAchQ,KACdiQ,OAAiBjQ,KACjBkQ,OAAuBlQ,OAazBN,EAAQyQ,aAAe,CACrBC,WAAY,2BACZC,SAAU,CACRC,IAAO,WAETC,SAAU,iCAIZ7Q,EAAQC,OAAO6Q,UAAU,SAAU9Q,EAAQyQ,cAS3CzQ,EAAQ+Q,uBAAyB,SAASC,EAAcC,GAKtD3O,KAAKsO,IAMLtO,KAAK4O,cAAgBF,EAMrB1O,KAAK6O,cAAgBF,GAjBvBjR,EAAQ+Q,+DAoBR/Q,EAAQC,OAAOyQ,WAAW,mBAAoB1Q,EAAQ+Q,wBAEtD/Q,EAAQ+Q,uBAAuBlS,UAAUuS,QAAU,WAAW,IAAApC,EAAA1M,KAC5D,IAAM+O,EAAO/O,KAAKsO,IAAIU,UAEtB,IAAIC,EAAOjP,KAAK4O,cAAcM,SAAS,KACvCD,EAAOA,IAAS/O,WAAa+O,EAAO,EAEpC,IAAMpD,EAAI7L,KAAK4O,cAAcM,SAAS,KACtC,IAAMpD,EAAI9L,KAAK4O,cAAcM,SAAS,KACtC,IAAMC,EAAUtD,IAAM3L,WAAe4L,IAAM5L,UACzC,EAAE2L,GAAIC,GAAK,CAAC,EAAG,GAEjBiD,EAAKK,UAAUD,GACfJ,EAAKM,QAAQJ,GAEbjP,KAAK4O,cAAcU,aAAa,CAC9BC,EAAKN,EACLpD,EAAKtD,KAAKC,MAAM2G,EAAO,IACvBrD,EAAKvD,KAAKC,MAAM2G,EAAO,MAGzBJ,EAAKS,GAAG,iBACNxP,KAAK6O,cAIH,SAACY,GACC,IAAMN,EAASJ,EAAKW,YACpB,IAAMC,EAAS,CACbJ,EAAKR,EAAKa,UACV/D,EAAKtD,KAAKC,MAAM2G,EAAO,IACvBrD,EAAKvD,KAAKC,MAAM2G,EAAO,KAEzBzC,EAAKkC,cAAcU,aAAaK,IAC/B,IAAuB,QAQhCjS,EAAQmS,cAAgB,CACtBzB,WAAY,4BACZC,SAAU,CACRC,IAAO,cACPwB,MAAS,iBAEXvB,SACI,yBACA,+DACA,eACA,6DAIN7Q,EAAQC,OAAO6Q,UAAU,UAAW9Q,EAAQmS,eAU5CnS,EAAQqS,wBAA0B,SAASC,EAAQtB,GAMjD1O,KAAKsO,IAKLtO,KAAK8P,MAML9P,KAAK4O,cAAgBF,EAMrB1O,KAAKiQ,OAASD,EAMdhQ,KAAKkQ,YAAc,EAMnBlQ,KAAKmQ,aAnCPzS,EAAQqS,0DAsCRrS,EAAQqS,wBAAwBxT,UAAUuS,QAAU,WAAW,IAAAsB,EAAApQ,KAC7D,IAAMqQ,EAAerQ,KAAK8P,MAAMQ,YAEhCtQ,KAAKmQ,YAAc,IAAII,OAAkB,CACvCC,KAA2C,aAC3CC,OAAQJ,IAGVrQ,KAAKmQ,YAAYO,UAAU,OAC3B1Q,KAAKsO,IAAIqC,eAAe3Q,KAAKmQ,aAC7BS,OAAiBT,YAAYnQ,KAAKmQ,aAElCnQ,KAAKmQ,YAAYX,GAAG,UAAW,SAASC,GACtCA,EAAEtN,QAAQoK,IAAI,OAAQvM,KAAKkQ,cAC1BlQ,MAIH,IAAM6Q,EAAW,IAAIC,EAErBT,EAAab,GAAG,aAAc,SAACC,GAC7B,IAAMtN,EAAUsN,EAAEtN,QAClBA,EAAQvB,SAAS,IAAIkH,OAAa,CAChCF,OAAQ,IAAIH,OAAc,CACxBD,MAAO,CAAC,IAAK,EAAG,EAAG,GACnBE,MAAO,OAGX,IAAMiF,EAAW0D,EAAaU,cAC9B,IAAMC,EAAkBH,EAAS7O,cAAc2K,GAC/CyD,EAAKH,OAAOgB,YAAY,WACtBb,EAAKxB,cAAcU,aAAa,CAAC3C,SAAYqE,QAIjD,IAAMA,EAAkBhR,KAAK4O,cAAcM,SAAS,YACpD,GAAI8B,IAAoB9Q,UAAW,CACjC,IAAMyM,EAAWkE,EAAShP,aAAamP,GACvChR,KAAKkQ,YAAcvD,EAASxQ,OAC5BkU,EAAaa,YAAYvE,KAS7BjP,EAAQqS,wBAAwBxT,UAAU4U,WAAa,WACrDnR,KAAK8P,MAAMQ,YAAYc,MAAM,MAC7BpR,KAAKkQ,YAAc,EACnBlQ,KAAK4O,cAAcyC,YAAY,aAGjC3T,EAAQC,OAAOyQ,WAAW,oBAAqB1Q,EAAQqS,yBAMvDrS,EAAQ4T,eAAiB,WAMvBtR,KAAKsO,IAAM,IAAIiD,OAAM,CACnBC,OAAQ,CACN,IAAIC,OAAY,CACdhB,OAAQ,IAAIiB,YAMlB,IAAMrB,EAAe,IAAIsB,OAMzB3R,KAAK4R,YAAc,IAAIC,OAAc,CACnCpB,OAAQJ,IAKVrQ,KAAK4R,YAAYE,OAAO9R,KAAKsO,MAK/B5Q,EAAQC,OAAOyQ,WAAW,iBAAkB1Q,EAAQ4T,gBAGrC5T","file":"permalink.8af34f.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t32: 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([500,0]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","/**\n * @module ngeo.format.FeatureHashStyleType\n */\n/**\n * @enum {string}\n * @export\n */\nconst exports = {\n  LINE_STRING: 'LineString',\n  POINT: 'Point',\n  POLYGON: 'Polygon'\n};\n\n\nexport default exports;\n","/**\n * @module ngeo.format.FeatureHash\n */\nimport googAsserts from 'goog/asserts.js';\nimport ngeoFormatFeatureProperties from 'ngeo/format/FeatureProperties.js';\nimport ngeoFormatFeatureHashStyleType from 'ngeo/format/FeatureHashStyleType.js';\nimport ngeoUtils from 'ngeo/utils.js';\nimport * as olBase from 'ol/index.js';\nimport olFeature from 'ol/Feature.js';\nimport * as olColor from 'ol/color.js';\nimport * as olArray from 'ol/array.js';\nimport * as olFormatFeature from 'ol/format/Feature.js';\nimport olFormatTextFeature from 'ol/format/TextFeature.js';\nimport olGeomGeometryLayout from 'ol/geom/GeometryLayout.js';\nimport olGeomLineString from 'ol/geom/LineString.js';\nimport olGeomMultiLineString from 'ol/geom/MultiLineString.js';\nimport olGeomMultiPoint from 'ol/geom/MultiPoint.js';\nimport olGeomMultiPolygon from 'ol/geom/MultiPolygon.js';\nimport olGeomPoint from 'ol/geom/Point.js';\nimport olGeomPolygon from 'ol/geom/Polygon.js';\nimport olStyleCircle from 'ol/style/Circle.js';\nimport olStyleFill from 'ol/style/Fill.js';\nimport olStyleStroke from 'ol/style/Stroke.js';\nimport olStyleStyle from 'ol/style/Style.js';\nimport olStyleText from 'ol/style/Text.js';\n\n/**\n * @classdesc\n * Provide an OpenLayers format for encoding and decoding features for use\n * in permalinks.\n *\n * The code is based on Stéphane Brunner's URLCompressed format.\n *\n * TODOs:\n *\n * - The OpenLayers-URLCompressed format has options where the user\n *   can define attribute and style transformers. This is currently\n *   not supported by this format.\n * - The OpenLayers-URLCompressed format has a \"simplify\" option.\n *   This format does not have it.\n * - ol.style.Icon styles are not supported.\n * - Transformation of coordinates during encoding and decoding is\n *   not supported.\n *\n * @see https://github.com/sbrunner/OpenLayers-URLCompressed\n * @constructor\n * @struct\n * @extends {ol.format.TextFeature}\n * @param {ngeox.format.FeatureHashOptions=} opt_options Options.\n */\nconst exports = function(opt_options) {\n\n  olFormatTextFeature.call(this);\n\n  const options = opt_options !== undefined ? opt_options : {};\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.accuracy_ = options.accuracy !== undefined ?\n    options.accuracy : exports.ACCURACY_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.encodeStyles_ = options.encodeStyles !== undefined ?\n    options.encodeStyles : true;\n\n  /**\n   * @type {function(ol.Feature):Object.<string, (string|number)>}\n   * @private\n   */\n  this.propertiesFunction_ = options.properties !== undefined ?\n    options.properties : exports.defaultPropertiesFunction_;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.setStyle_ = options.setStyle !== undefined ? options.setStyle : true;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevX_ = 0;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.prevY_ = 0;\n\n  /**\n   * @type {Object.<string, string>}\n   * @private\n   */\n  exports.LegacyProperties_ = (options.propertiesType !== undefined) && options.propertiesType;\n\n  /**\n   * @type {Object.<string, function(ol.Feature)>}\n   * @private\n   */\n  this.defaultValues_ = options.defaultValues !== undefined ? options.defaultValues : {};\n\n};\n\nolBase.inherits(exports, olFormatTextFeature);\n\n\n/**\n * @type {Object.<ol.geom.GeometryType, ngeo.format.FeatureHashStyleType>}\n * @private\n */\nexports.StyleTypes_ = {\n  'LineString': ngeoFormatFeatureHashStyleType.LINE_STRING,\n  'Point': ngeoFormatFeatureHashStyleType.POINT,\n  'Polygon': ngeoFormatFeatureHashStyleType.POLYGON,\n  'MultiLineString': ngeoFormatFeatureHashStyleType.LINE_STRING,\n  'MultiPoint': ngeoFormatFeatureHashStyleType.POINT,\n  'MultiPolygon': ngeoFormatFeatureHashStyleType.POLYGON\n};\n\n/**\n * @type {Object.<string, string>}\n * @private\n */\nexports.LegacyProperties_ = {};\n\n\n/**\n * @inheritDoc\n */\nexports.prototype.readFeature;\n\n\n/**\n * @inheritDoc\n */\nexports.prototype.readFeatures;\n\n\n/**\n * @inheritDoc\n */\nexports.prototype.readGeometry;\n\n\n/**\n * @inheritDoc\n */\nexports.prototype.writeFeature;\n\n\n/**\n * @inheritDoc\n */\nexports.prototype.writeFeatures;\n\n\n/**\n * @inheritDoc\n */\nexports.prototype.writeGeometry;\n\n\n/**\n * Characters used to encode the coordinates. The characters \"~\", \"'\", \"(\"\n * and \")\" are not part of this character set, and used as separators (for\n * example to separate the coordinates from the feature properties).\n * @const\n * @private\n */\nexports.CHAR64_ =\n    '.-_!*ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghjkmnpqrstuvwxyz';\n\n\n/**\n * @const\n * @private\n */\nexports.ACCURACY_ = 0.1;\n\n\n/**\n * Get features's properties.\n * @param {ol.Feature} feature Feature.\n * @return {Object.<string, (string|number)>} The feature properties to\n * serialize.\n * @private\n */\nexports.defaultPropertiesFunction_ = function(feature) {\n  return feature.getProperties();\n};\n\n\n/**\n * Sign then encode a number.\n * @param {number} num Number.\n * @return {string} String.\n * @private\n */\nexports.encodeSignedNumber_ = function(num) {\n  let signedNum = num << 1;\n  if (num < 0) {\n    signedNum = ~(signedNum);\n  }\n  return exports.encodeNumber_(signedNum);\n};\n\n\n/**\n * Transform a number into a logical sequence of characters.\n * @param {number} num Number.\n * @return {string} String.\n * @private\n */\nexports.encodeNumber_ = function(num) {\n  let encodedNumber = '';\n  while (num >= 0x20) {\n    encodedNumber += exports.CHAR64_.charAt(\n      0x20 | (num & 0x1f));\n    num >>= 5;\n  }\n  encodedNumber += exports.CHAR64_.charAt(num);\n  return encodedNumber;\n};\n\n\n/**\n * For a type of geometry, transforms an array of {@link ol.style.Style} into\n * a logical sequence of characters and put the result into the given encoded\n * styles's array.\n * @param {Array.<ol.style.Style>} styles Styles.\n * @param {ol.geom.GeometryType} geometryType Geometry type.\n * @param {Array.<string>} encodedStyles Encoded styles array.\n * @private\n */\nexports.encodeStyles_ = function(styles, geometryType, encodedStyles) {\n  const styleType = exports.StyleTypes_[geometryType];\n  googAsserts.assert(styleType !== undefined);\n  for (let i = 0; i < styles.length; ++i) {\n    const style = styles[i];\n    const fillStyle = style.getFill();\n    const imageStyle = style.getImage();\n    const strokeStyle = style.getStroke();\n    const textStyle = style.getText();\n    if (styleType == ngeoFormatFeatureHashStyleType.POLYGON) {\n      if (fillStyle !== null) {\n        exports.encodeStylePolygon_(\n          fillStyle, strokeStyle, encodedStyles);\n      }\n    } else if (styleType == ngeoFormatFeatureHashStyleType.LINE_STRING) {\n      if (strokeStyle !== null) {\n        exports.encodeStyleLine_(strokeStyle, encodedStyles);\n      }\n    } else if (styleType == ngeoFormatFeatureHashStyleType.POINT) {\n      if (imageStyle !== null) {\n        exports.encodeStylePoint_(imageStyle, encodedStyles);\n      }\n    }\n    if (textStyle !== null) {\n      exports.encodeStyleText_(textStyle, encodedStyles);\n    }\n  }\n};\n\n\n/**\n * Transform an {@link ol.style.Stroke} into a logical sequence of\n * characters and put the result into the given encoded styles's array.\n * @param {ol.style.Stroke} strokeStyle Stroke style.\n * @param {Array.<string>} encodedStyles Encoded styles array.\n * @private\n */\nexports.encodeStyleLine_ = function(strokeStyle, encodedStyles) {\n  exports.encodeStyleStroke_(strokeStyle, encodedStyles);\n};\n\n\n/**\n * Transform an {@link ol.style.Circle} into a logical sequence of\n * characters and put the result into the given encoded styles's array.\n * @param {ol.style.Image} imageStyle Image style.\n * @param {Array.<string>} encodedStyles Encoded styles array.\n * @private\n */\nexports.encodeStylePoint_ = function(imageStyle, encodedStyles) {\n  if (imageStyle instanceof olStyleCircle) {\n    const radius = imageStyle.getRadius();\n    if (encodedStyles.length > 0) {\n      encodedStyles.push('\\'');\n    }\n    encodedStyles.push(encodeURIComponent(`pointRadius*${radius}`));\n    const fillStyle = imageStyle.getFill();\n    if (fillStyle !== null) {\n      exports.encodeStyleFill_(fillStyle, encodedStyles);\n    }\n    const strokeStyle = imageStyle.getStroke();\n    if (strokeStyle !== null) {\n      exports.encodeStyleStroke_(strokeStyle, encodedStyles);\n    }\n  }\n};\n\n\n/**\n * Transform an {@link ol.style.Fill} and an {@link ol.style.Stroke} into\n * a logical sequence of characters and put the result into the given\n * encoded styles's array.\n * @param {ol.style.Fill} fillStyle Fill style.\n * @param {ol.style.Stroke} strokeStyle Stroke style.\n * @param {Array.<string>} encodedStyles Encoded styles array.\n * @private\n */\nexports.encodeStylePolygon_ = function(fillStyle, strokeStyle, encodedStyles) {\n  exports.encodeStyleFill_(fillStyle, encodedStyles);\n  if (strokeStyle !== null) {\n    exports.encodeStyleStroke_(strokeStyle, encodedStyles);\n  }\n};\n\n\n/**\n * Transform an {@link ol.style.Fill} and optionally its properties into\n * a logical sequence of characters and put the result into the given encoded\n * styles's array.\n * @param {ol.style.Fill} fillStyle Fill style.\n * @param {Array.<string>} encodedStyles Encoded styles array.\n * @param {string=} opt_propertyName Property name.\n * @private\n */\nexports.encodeStyleFill_ = function(fillStyle, encodedStyles, opt_propertyName) {\n  const propertyName = opt_propertyName !== undefined ?\n    opt_propertyName : 'fillColor';\n  const fillColor = fillStyle.getColor();\n  if (fillColor !== null) {\n    googAsserts.assert(Array.isArray(fillColor), 'only supporting fill colors');\n    const fillColorRgba = olColor.asArray(fillColor);\n    googAsserts.assert(Array.isArray(fillColorRgba), 'fill color must be an array');\n    const fillColorHex = ngeoUtils.rgbArrayToHex(fillColorRgba);\n    if (encodedStyles.length > 0) {\n      encodedStyles.push('\\'');\n    }\n    encodedStyles.push(\n      encodeURIComponent(`${propertyName}*${fillColorHex}`));\n  }\n};\n\n\n/**\n * Transform an {@link ol.style.Stroke} into a logical sequence of\n * characters and put the result into the given encoded styles's array.\n * @param {ol.style.Stroke} strokeStyle Stroke style.\n * @param {Array.<string>} encodedStyles Encoded styles array.\n * @private\n */\nexports.encodeStyleStroke_ = function(strokeStyle, encodedStyles) {\n  const strokeColor = strokeStyle.getColor();\n  if (strokeColor !== null) {\n    googAsserts.assert(Array.isArray(strokeColor));\n    const strokeColorRgba = olColor.asArray(strokeColor);\n    googAsserts.assert(Array.isArray(strokeColorRgba), 'only supporting stroke colors');\n    const strokeColorHex = ngeoUtils.rgbArrayToHex(strokeColorRgba);\n    if (encodedStyles.length > 0) {\n      encodedStyles.push('\\'');\n    }\n    encodedStyles.push(encodeURIComponent(`strokeColor*${strokeColorHex}`));\n  }\n  const strokeWidth = strokeStyle.getWidth();\n  if (strokeWidth !== undefined) {\n    if (encodedStyles.length > 0) {\n      encodedStyles.push('\\'');\n    }\n    encodedStyles.push(encodeURIComponent(`strokeWidth*${strokeWidth}`));\n  }\n};\n\n\n/**\n * Transform an {@link ol.style.Text} into a logical sequence of characters and\n * put the result into the given encoded styles's array.\n * @param {ol.style.Text} textStyle Text style.\n * @param {Array.<string>} encodedStyles Encoded styles array.\n * @private\n */\nexports.encodeStyleText_ = function(textStyle, encodedStyles) {\n  const fontStyle = textStyle.getFont();\n  if (fontStyle !== undefined) {\n    const font = fontStyle.split(' ');\n    if (font.length >= 3) {\n      if (encodedStyles.length > 0) {\n        encodedStyles.push('\\'');\n      }\n      encodedStyles.push(encodeURIComponent(`fontSize*${font[1]}`));\n    }\n  }\n  const fillStyle = textStyle.getFill();\n  if (fillStyle !== null) {\n    exports.encodeStyleFill_(\n      fillStyle, encodedStyles, 'fontColor');\n  }\n};\n\n\n/**\n * Read a logical sequence of characters and return a corresponding\n * {@link ol.geom.LineString}.\n * @param {string} text Text.\n * @return {ol.geom.LineString} Line string.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.readLineStringGeometry_ = function(text) {\n  googAsserts.assert(text.substring(0, 2) === 'l(');\n  googAsserts.assert(text[text.length - 1] == ')');\n  text = text.substring(2, text.length - 1);\n  const flatCoordinates = this.decodeCoordinates_(text);\n  return new olGeomLineString(flatCoordinates, olGeomGeometryLayout.XY);\n};\n\n\n/**\n * Read a logical sequence of characters and return a corresponding\n * {@link ol.geom.MultiLineString}.\n * @param {string} text Text.\n * @return {ol.geom.MultiLineString} Line string.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.readMultiLineStringGeometry_ = function(text) {\n  googAsserts.assert(text.substring(0, 2) === 'L(');\n  googAsserts.assert(text[text.length - 1] == ')');\n  text = text.substring(2, text.length - 1);\n  let flatCoordinates = [];\n  const ends = [];\n  const lineStrings = text.split('\\'');\n  for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n    flatCoordinates = this.decodeCoordinates_(lineStrings[i], flatCoordinates);\n    ends[i] = flatCoordinates.length;\n  }\n  return new olGeomMultiLineString(flatCoordinates, olGeomGeometryLayout.XY, ends);\n};\n\n\n/**\n * Read a logical sequence of characters and return a corresponding\n * {@link ol.geom.Point}.\n * @param {string} text Text.\n * @return {ol.geom.Point} Point.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.readPointGeometry_ = function(text) {\n  googAsserts.assert(text.substring(0, 2) === 'p(');\n  googAsserts.assert(text[text.length - 1] == ')');\n  text = text.substring(2, text.length - 1);\n  const flatCoordinates = this.decodeCoordinates_(text);\n  googAsserts.assert(flatCoordinates.length === 2);\n  return new olGeomPoint(flatCoordinates, olGeomGeometryLayout.XY);\n};\n\n\n/**\n * Read a logical sequence of characters and return a corresponding\n * {@link ol.geom.MultiPoint}.\n * @param {string} text Text.\n * @return {ol.geom.MultiPoint} MultiPoint.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.readMultiPointGeometry_ = function(text) {\n  googAsserts.assert(text.substring(0, 2) === 'P(');\n  googAsserts.assert(text[text.length - 1] == ')');\n  text = text.substring(2, text.length - 1);\n  const flatCoordinates = this.decodeCoordinates_(text);\n  return new olGeomMultiPoint(flatCoordinates, olGeomGeometryLayout.XY);\n};\n\n\n/**\n * Read a logical sequence of characters and return a corresponding\n * {@link ol.geom.Polygon}.\n * @param {string} text Text.\n * @return {ol.geom.Polygon} Polygon.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.readPolygonGeometry_ = function(text) {\n  googAsserts.assert(text.substring(0, 2) === 'a(');\n  googAsserts.assert(text[text.length - 1] == ')');\n  text = text.substring(2, text.length - 1);\n  let flatCoordinates = [];\n  const ends = [];\n  const rings = text.split('\\'');\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    flatCoordinates = this.decodeCoordinates_(rings[i], flatCoordinates);\n    let end = flatCoordinates.length;\n    if (i === 0) {\n      flatCoordinates[end++] = flatCoordinates[0];\n      flatCoordinates[end++] = flatCoordinates[1];\n    } else {\n      flatCoordinates[end++] = flatCoordinates[ends[i - 1]];\n      flatCoordinates[end++] = flatCoordinates[ends[i - 1] + 1];\n    }\n    ends[i] = end;\n  }\n  return new olGeomPolygon(flatCoordinates, olGeomGeometryLayout.XY, ends);\n};\n\n\n/**\n * Read a logical sequence of characters and return a corresponding\n * {@link ol.geom.MultiPolygon}.\n * @param {string} text Text.\n * @return {ol.geom.MultiPolygon} MultiPolygon.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.readMultiPolygonGeometry_ = function(text) {\n  googAsserts.assert(text.substring(0, 2) === 'A(');\n  googAsserts.assert(text[text.length - 1] == ')');\n  text = text.substring(2, text.length - 1);\n  let flatCoordinates = [];\n  const endss = [];\n  const polygons = text.split(')(');\n  for (let i = 0, ii = polygons.length; i < ii; ++i) {\n    const rings = polygons[i].split('\\'');\n    const ends = endss[i] = [];\n    for (let j = 0, jj = rings.length; j < jj; ++j) {\n      flatCoordinates = this.decodeCoordinates_(rings[j], flatCoordinates);\n      let end = flatCoordinates.length;\n      if (j === 0) {\n        flatCoordinates[end++] = flatCoordinates[0];\n        flatCoordinates[end++] = flatCoordinates[1];\n      } else {\n        flatCoordinates[end++] = flatCoordinates[ends[j - 1]];\n        flatCoordinates[end++] = flatCoordinates[ends[j - 1] + 1];\n      }\n      ends[j] = end;\n    }\n  }\n  return new olGeomMultiPolygon(flatCoordinates, olGeomGeometryLayout.XY, endss);\n};\n\n\n/**\n * DEPRECATED - Use the `ngeo.misc.FeatureHelper` instead in combination with the\n * `setStyle: false` option.\n *\n * Read a logical sequence of characters and apply the decoded style on the\n * given feature.\n * @param {string} text Text.\n * @param {ol.Feature} feature Feature.\n * @private\n */\nexports.setStyleInFeature_ = function(text, feature) {\n  if (text == '') {\n    return;\n  }\n  const properties = exports.getStyleProperties_(text, feature);\n  const fillColor = properties['fillColor'];\n  const fontSize = properties['fontSize'];\n  const fontColor = properties['fontColor'];\n  const pointRadius = properties['pointRadius'];\n  const strokeColor = properties['strokeColor'];\n  const strokeWidth = properties['strokeWidth'];\n\n  let fillStyle = null;\n  if (fillColor !== undefined) {\n    fillStyle = new olStyleFill({\n      color: /** @type {Array<number>|string} */ (fillColor)\n    });\n  }\n  let strokeStyle = null;\n  if (strokeColor !== undefined && strokeWidth !== undefined) {\n    strokeStyle = new olStyleStroke({\n      color: /** @type {Array<number>|string} */ (strokeColor),\n      width: /** @type {number} */ (strokeWidth)\n    });\n  }\n  let imageStyle = null;\n  if (pointRadius !== undefined) {\n    imageStyle = new olStyleCircle({\n      radius: /** @type {number} */ (pointRadius),\n      fill: fillStyle,\n      stroke: strokeStyle\n    });\n    fillStyle = strokeStyle = null;\n  }\n  let textStyle = null;\n  if (fontSize !== undefined && fontColor !== undefined) {\n    textStyle = new olStyleText({\n      font: `${fontSize} sans-serif`,\n      fill: new olStyleFill({\n        color: /** @type {Array<number>|string} */ (fontColor)\n      })\n    });\n  }\n  const style = new olStyleStyle({\n    fill: fillStyle,\n    image: imageStyle,\n    stroke: strokeStyle,\n    text: textStyle\n  });\n  feature.setStyle(style);\n};\n\n\n/**\n * Read a logical sequence of characters and apply the decoded result as\n * style properties for the feature. Legacy keys are converted to the new ones\n * for compatibility.\n * @param {string} text Text.\n * @param {ol.Feature} feature Feature.\n * @private\n */\nexports.setStyleProperties_ = function(text, feature) {\n\n  const properties = exports.getStyleProperties_(text, feature);\n  const geometry = feature.getGeometry();\n\n  // Deal with legacy properties\n  if (geometry instanceof olGeomPoint) {\n    if (properties['isLabel'] ||\n        properties[ngeoFormatFeatureProperties.IS_TEXT]) {\n      delete properties['strokeColor'];\n      delete properties['fillColor'];\n    } else {\n      delete properties['fontColor'];\n      delete properties['fontSize'];\n    }\n  } else {\n    delete properties['fontColor'];\n\n    if (geometry instanceof olGeomLineString) {\n      delete properties['fillColor'];\n      delete properties['fillOpacity'];\n    }\n  }\n\n  // Convert font size from px to pt\n  if (properties['fontSize']) {\n    let fontSize = parseFloat(properties['fontSize']);\n    if (properties['fontSize'].indexOf('px') !== -1) {\n      fontSize = Math.round(fontSize / 1.333333);\n    }\n    properties['fontSize'] = fontSize;\n  }\n\n  // Convert legacy properties\n  const clone = {};\n  for (const key in properties) {\n    const value = properties[key];\n    if (exports.LegacyProperties_[key]) {\n      clone[exports.LegacyProperties_[key]] = value;\n    } else {\n      clone[key] = value;\n    }\n  }\n\n  feature.setProperties(clone);\n};\n\n\n/**\n * Cast values in the correct type depending on the property.\n * @param {string} key Key.\n * @param {string} value Value.\n * @return {number|boolean|string} The casted value corresponding to the key.\n * @private\n */\nexports.castValue_ = function(key, value) {\n  const numProperties = [\n    ngeoFormatFeatureProperties.ANGLE,\n    ngeoFormatFeatureProperties.OPACITY,\n    ngeoFormatFeatureProperties.SIZE,\n    ngeoFormatFeatureProperties.STROKE,\n    'pointRadius',\n    'strokeWidth'\n  ];\n  const boolProperties = [\n    ngeoFormatFeatureProperties.IS_CIRCLE,\n    ngeoFormatFeatureProperties.IS_RECTANGLE,\n    ngeoFormatFeatureProperties.IS_TEXT,\n    ngeoFormatFeatureProperties.SHOW_MEASURE,\n    ngeoFormatFeatureProperties.SHOW_LABEL,\n    'isCircle',\n    'isRectangle',\n    'isLabel',\n    'showMeasure',\n    'showLabel'\n  ];\n\n  if (olArray.includes(numProperties, key)) {\n    return +value;\n  } else if (olArray.includes(boolProperties, key)) {\n    return (value === 'true') ? true : false;\n  } else {\n    return value;\n  }\n};\n\n\n/**\n * From a logical sequence of characters, create and return an object of\n * style properties for a feature. The values are cast in the correct type\n * depending on the property. Some properties are also deleted when they don't\n * match the geometry of the feature.\n * @param {string} text Text.\n * @param {ol.Feature} feature Feature.\n * @return {Object.<string, boolean|number|string>} The style properties for\n *     the feature.\n * @private\n */\nexports.getStyleProperties_ = function(text, feature) {\n  const parts = text.split('\\'');\n  const properties = {};\n\n  for (let i = 0; i < parts.length; ++i) {\n    const part = decodeURIComponent(parts[i]);\n    const keyVal = part.split('*');\n    googAsserts.assert(keyVal.length === 2);\n    const key = keyVal[0];\n    const val = keyVal[1];\n\n    properties[key] = exports.castValue_(key, val);\n  }\n\n  return properties;\n};\n\n\n/**\n * Encode a {@link ol.geom.LineString} geometry into a logical sequence of\n * characters.\n * @param {ol.geom.Geometry} geometry Geometry.\n * @return {string} Encoded geometry.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.writeLineStringGeometry_ = function(geometry) {\n  googAsserts.assertInstanceof(geometry, olGeomLineString);\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const stride = geometry.getStride();\n  const end = flatCoordinates.length;\n  return `l(${this.encodeCoordinates_(flatCoordinates, stride, 0, end)})`;\n};\n\n\n/**\n * Encode a {@link ol.geom.MultiLineString} geometry into a logical sequence\n * of characters.\n * @param {ol.geom.Geometry} geometry Geometry.\n * @return {string} Encoded geometry.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.writeMultiLineStringGeometry_ = function(geometry) {\n  googAsserts.assertInstanceof(geometry, olGeomMultiLineString);\n  const ends = geometry.getEnds();\n  const lineStringCount = ends.length;\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const stride = geometry.getStride();\n  let offset = 0;\n  const textArray = ['L('];\n  for (let i = 0; i < lineStringCount; ++i) {\n    const end = ends[i];\n    const text = this.encodeCoordinates_(flatCoordinates, stride, offset, end);\n    if (i !== 0) {\n      textArray.push('\\'');\n    }\n    textArray.push(text);\n    offset = end;\n  }\n  textArray.push(')');\n  return textArray.join('');\n};\n\n\n/**\n * Encode a {@link ol.geom.Point} geometry into a logical sequence of\n * characters.\n * @param {ol.geom.Geometry} geometry Geometry.\n * @return {string} Encoded geometry.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.writePointGeometry_ = function(geometry) {\n  googAsserts.assertInstanceof(geometry, olGeomPoint);\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const stride = geometry.getStride();\n  const end = flatCoordinates.length;\n  return `p(${this.encodeCoordinates_(flatCoordinates, stride, 0, end)})`;\n};\n\n\n/**\n * Encode an {@link ol.geom.MultiPoint} geometry into a logical sequence\n * of characters.\n * @param {ol.geom.Geometry} geometry Geometry.\n * @return {string} Encoded geometry.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.writeMultiPointGeometry_ = function(geometry) {\n  googAsserts.assertInstanceof(geometry, olGeomMultiPoint);\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const stride = geometry.getStride();\n  const end = flatCoordinates.length;\n  return `P(${this.encodeCoordinates_(flatCoordinates, stride, 0, end)})`;\n};\n\n\n/**\n * Helper to encode an {@link ol.geom.Polygon} geometry.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} stride Stride.\n * @param {number} offset Offset.\n * @param {Array.<number>} ends Ends.\n * @param {Array.<string>} textArray Text array.\n * @return {number} The new offset.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.encodeRings_ = function(flatCoordinates, stride, offset, ends, textArray) {\n  const linearRingCount = ends.length;\n  for (let i = 0; i < linearRingCount; ++i) {\n    // skip the \"closing\" point\n    const end = ends[i] - stride;\n    const text = this.encodeCoordinates_(flatCoordinates, stride, offset, end);\n    if (i !== 0) {\n      textArray.push('\\'');\n    }\n    textArray.push(text);\n    offset = ends[i];\n  }\n  return offset;\n};\n\n\n/**\n * Encode an {@link ol.geom.Polygon} geometry into a logical sequence\n * of characters.\n * @param {ol.geom.Geometry} geometry Geometry.\n * @return {string} Encoded geometry.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.writePolygonGeometry_ = function(geometry) {\n  googAsserts.assertInstanceof(geometry, olGeomPolygon);\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const stride = geometry.getStride();\n  const ends = geometry.getEnds();\n  const offset = 0;\n  const textArray = ['a('];\n  exports.encodeRings_.call(this,\n    flatCoordinates, stride, offset, ends, textArray);\n  textArray.push(')');\n  return textArray.join('');\n};\n\n\n/**\n * Encode an {@link ol.geom.MultiPoligon} geometry into a logical sequence of\n * characters.\n * @param {ol.geom.Geometry} geometry Geometry.\n * @return {string} Encoded geometry.\n * @this {ngeo.format.FeatureHash}\n * @private\n */\nexports.writeMultiPolygonGeometry_ = function(geometry) {\n  googAsserts.assertInstanceof(geometry, olGeomMultiPolygon);\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const stride = geometry.getStride();\n  const endss = geometry.getEndss();\n  const polygonCount = endss.length;\n  let offset = 0;\n  const textArray = ['A'];\n  for (let i = 0; i < polygonCount; ++i) {\n    const ends = endss[i];\n    textArray.push('(');\n    offset = exports.encodeRings_.call(this,\n      flatCoordinates, stride, offset, ends, textArray);\n    textArray.push(')');\n  }\n  return textArray.join('');\n};\n\n\n/**\n * @const\n * @private\n * @type {Object.<string, function(string):ol.geom.Geometry>}\n */\nexports.GEOMETRY_READERS_ = {\n  'P': exports.readMultiPointGeometry_,\n  'L': exports.readMultiLineStringGeometry_,\n  'A': exports.readMultiPolygonGeometry_,\n  'l': exports.readLineStringGeometry_,\n  'p': exports.readPointGeometry_,\n  'a': exports.readPolygonGeometry_\n};\n\n\n/**\n * @const\n * @private\n * @type {Object.<string, function(ol.geom.Geometry):string>}\n */\nexports.GEOMETRY_WRITERS_ = {\n  'MultiLineString': exports.writeMultiLineStringGeometry_,\n  'MultiPoint': exports.writeMultiPointGeometry_,\n  'MultiPolygon': exports.writeMultiPolygonGeometry_,\n  'LineString': exports.writeLineStringGeometry_,\n  'Point': exports.writePointGeometry_,\n  'Polygon': exports.writePolygonGeometry_\n};\n\n\n/**\n * Read a logical sequence of characters and return (or complete then return)\n * an array of numbers. The coordinates are assumed to be in\n * two dimensions and in latitude, longitude order.\n * corresponding to a geometry's coordinates.\n * @param {string} text Text.\n * @param {Array.<number>=} opt_flatCoordinates Flat coordinates array.\n * @return {Array.<number>} Flat coordinates.\n * @private\n */\nexports.prototype.decodeCoordinates_ = function(text, opt_flatCoordinates) {\n  const len = text.length;\n  let index = 0;\n  const flatCoordinates = opt_flatCoordinates !== undefined ?\n    opt_flatCoordinates : [];\n  let i = flatCoordinates.length;\n  while (index < len) {\n    let b;\n    let shift = 0;\n    let result = 0;\n    do {\n      b = exports.CHAR64_.indexOf(text.charAt(index++));\n      result |= (b & 0x1f) << shift;\n      shift += 5;\n    } while (b >= 32);\n    const dx = ((result & 1) ? ~(result >> 1) : (result >> 1));\n    this.prevX_ += dx;\n    shift = 0;\n    result = 0;\n    do {\n      b = exports.CHAR64_.indexOf(text.charAt(index++));\n      result |= (b & 0x1f) << shift;\n      shift += 5;\n    } while (b >= 32);\n    const dy = ((result & 1) ? ~(result >> 1) : (result >> 1));\n    this.prevY_ += dy;\n    flatCoordinates[i++] = this.prevX_ * this.accuracy_;\n    flatCoordinates[i++] = this.prevY_ * this.accuracy_;\n  }\n  return flatCoordinates;\n};\n\n\n/**\n * Encode an array of number (corresponding to some coordinates) into a\n * logical sequence of characters. The coordinates are assumed to be in\n * two dimensions and in latitude, longitude order.\n * @param {Array.<number>} flatCoordinates Flat coordinates.\n * @param {number} stride Stride.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @return {string} String.\n * @private\n */\nexports.prototype.encodeCoordinates_ = function(flatCoordinates, stride, offset, end) {\n  let encodedCoordinates = '';\n  for (let i = offset; i < end; i += stride) {\n    let x = flatCoordinates[i];\n    let y = flatCoordinates[i + 1];\n    x = Math.floor(x / this.accuracy_);\n    y = Math.floor(y / this.accuracy_);\n    const dx = x - this.prevX_;\n    const dy = y - this.prevY_;\n    this.prevX_ = x;\n    this.prevY_ = y;\n    encodedCoordinates += exports.encodeSignedNumber_(dx) +\n        exports.encodeSignedNumber_(dy);\n  }\n  return encodedCoordinates;\n};\n\n\n/**\n * Read a feature from a logical sequence of characters.\n * @param {string} text Text.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.Feature} Feature.\n * @protected\n * @override\n */\nexports.prototype.readFeatureFromText = function(text, opt_options) {\n  googAsserts.assert(text.length > 2);\n  googAsserts.assert(text[1] === '(');\n  googAsserts.assert(text[text.length - 1] === ')');\n  let splitIndex = text.indexOf('~');\n  const geometryText = splitIndex >= 0 ?\n    `${text.substring(0, splitIndex)})` : text;\n  const geometry = this.readGeometryFromText(geometryText, opt_options);\n  const feature = new olFeature(geometry);\n  if (splitIndex >= 0) {\n    const attributesAndStylesText = text.substring(\n      splitIndex + 1, text.length - 1);\n    splitIndex = attributesAndStylesText.indexOf('~');\n    const attributesText = splitIndex >= 0 ?\n      attributesAndStylesText.substring(0, splitIndex) :\n      attributesAndStylesText;\n    if (attributesText != '') {\n      const parts = attributesText.split('\\'');\n      for (let i = 0; i < parts.length; ++i) {\n        const part = decodeURIComponent(parts[i]);\n        const keyVal = part.split('*');\n        googAsserts.assert(keyVal.length === 2);\n        let key = keyVal[0];\n        const value = keyVal[1];\n        if (!this.setStyle_ && exports.LegacyProperties_[key]) {\n          key = exports.LegacyProperties_[key];\n        }\n        feature.set(key, exports.castValue_(key, value));\n      }\n    }\n    if (splitIndex >= 0) {\n      const stylesText = attributesAndStylesText.substring(splitIndex + 1);\n      if (this.setStyle_) {\n        exports.setStyleInFeature_(stylesText, feature);\n      } else {\n        exports.setStyleProperties_(stylesText, feature);\n      }\n    }\n  }\n  return feature;\n};\n\n\n/**\n * Read multiple features from a logical sequence of characters.\n * @param {string} text Text.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {Array.<ol.Feature>} Features.\n * @protected\n * @override\n */\nexports.prototype.readFeaturesFromText = function(text, opt_options) {\n  googAsserts.assert(text[0] === 'F');\n  this.prevX_ = 0;\n  this.prevY_ = 0;\n  /** @type {Array.<ol.Feature>} */\n  const features = [];\n  text = text.substring(1);\n  while (text.length > 0) {\n    const index = text.indexOf(')');\n    googAsserts.assert(index >= 0);\n    const feature = this.readFeatureFromText(\n      text.substring(0, index + 1), opt_options);\n    features.push(feature);\n    text = text.substring(index + 1);\n  }\n\n  // set default values\n  features.forEach((feature) => {\n    for (const key in this.defaultValues_) {\n      const property = exports.LegacyProperties_[key];\n      if (feature.get(property) === undefined) {\n        feature.set(property, this.defaultValues_[key].call(null, feature));\n      }\n    }\n  });\n  return features;\n};\n\n\n/**\n * Read a geometry from a logical sequence of characters.\n * @param {string} text Text.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {ol.geom.Geometry} Geometry.\n * @protected\n * @override\n */\nexports.prototype.readGeometryFromText = function(text, opt_options) {\n  const geometryReader = exports.GEOMETRY_READERS_[text[0]];\n  googAsserts.assert(geometryReader !== undefined);\n  return geometryReader.call(this, text);\n};\n\n\n/**\n * Encode a feature into a logical sequence of characters.\n * @param {ol.Feature} feature Feature.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {string} Encoded feature.\n * @protected\n * @override\n */\nexports.prototype.writeFeatureText = function(feature, opt_options) {\n  const /** @type {Array.<string>} */ encodedParts = [];\n\n  // encode geometry\n\n  let encodedGeometry = '';\n  const geometry = feature.getGeometry();\n  if (geometry) {\n    encodedGeometry = this.writeGeometryText(geometry, opt_options);\n  }\n\n  if (encodedGeometry.length > 0) {\n    // remove the final bracket\n    googAsserts.assert(encodedGeometry[encodedGeometry.length - 1] === ')');\n    encodedGeometry = encodedGeometry.substring(0, encodedGeometry.length - 1);\n    encodedParts.push(encodedGeometry);\n  }\n\n  // encode properties\n\n  const /** @type {Array.<string>} */ encodedProperties = [];\n  const propFunction = this.propertiesFunction_(feature);\n  for (const key in propFunction) {\n    const value = propFunction[key];\n    if (value !== undefined && value !== null && key !== feature.getGeometryName()) {\n      if (encodedProperties.length !== 0) {\n        encodedProperties.push('\\'');\n      }\n      const encoded = encodeURIComponent(\n        `${key.replace(/[()'*]/g, '_')}*${\n          value.toString().replace(/[()'*]/g, '_')}`);\n      encodedProperties.push(encoded);\n    }\n  }\n\n  if (encodedProperties.length > 0) {\n    encodedParts.push('~');\n    Array.prototype.push.apply(encodedParts, encodedProperties);\n  }\n\n  // encode styles\n\n  if (this.encodeStyles_) {\n    const styleFunction = feature.getStyleFunction();\n    if (styleFunction !== undefined) {\n      let styles = styleFunction.call(feature, 0);\n      if (styles !== null) {\n        const encodedStyles = [];\n        styles = Array.isArray(styles) ? styles : [styles];\n        exports.encodeStyles_(\n          styles, geometry.getType(), encodedStyles);\n        if (encodedStyles.length > 0) {\n          encodedParts.push('~');\n          Array.prototype.push.apply(encodedParts, encodedStyles);\n        }\n      }\n    }\n  }\n\n  // append the closing bracket and return the encoded feature\n\n  encodedParts.push(')');\n  return encodedParts.join('');\n};\n\n\n/**\n * Encode an array of features into a logical sequence of characters.\n * @param {Array.<ol.Feature>} features Feature.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {string} Encoded features.\n * @protected\n * @override\n */\nexports.prototype.writeFeaturesText = function(features, opt_options) {\n  this.prevX_ = 0;\n  this.prevY_ = 0;\n  const textArray = [];\n  if (features.length > 0) {\n    textArray.push('F');\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      textArray.push(this.writeFeatureText(features[i], opt_options));\n    }\n  }\n  return textArray.join('');\n};\n\n\n/**\n * Encode a geometry into a logical sequence of characters.\n * @param {ol.geom.Geometry} geometry Geometry.\n * @param {olx.format.ReadOptions=} opt_options Read options.\n * @return {string} Encoded geometry.\n * @protected\n * @override\n */\nexports.prototype.writeGeometryText = function(geometry, opt_options) {\n  const geometryWriter = exports.GEOMETRY_WRITERS_[\n    geometry.getType()];\n  googAsserts.assert(geometryWriter !== undefined);\n  const transformedGeometry = /** @type {ol.geom.Geometry} */\n      (olFormatFeature.transformWithOptions(geometry, true, opt_options));\n  return geometryWriter.call(this, transformedGeometry);\n};\n\n\nexport default exports;\n","/**\n * @module app.permalink\n */\nconst exports = {};\n\nimport './permalink.css';\nimport ngeoFormatFeatureHash from 'ngeo/format/FeatureHash.js';\n\nimport ngeoMapModule from 'ngeo/map/module.js';\nimport ngeoMiscDebounce from 'ngeo/misc/debounce.js';\nimport ngeoMiscDecorate from 'ngeo/misc/decorate.js';\nimport ngeoStatemanagerModule from 'ngeo/statemanager/module.js';\nimport olMap from 'ol/Map.js';\nimport olInteractionDraw from 'ol/interaction/Draw.js';\nimport olLayerTile from 'ol/layer/Tile.js';\nimport olLayerVector from 'ol/layer/Vector.js';\nimport olSourceOSM from 'ol/source/OSM.js';\nimport olSourceVector from 'ol/source/Vector.js';\nimport olStyleStroke from 'ol/style/Stroke.js';\nimport olStyleStyle from 'ol/style/Style.js';\n\n\n/** @type {!angular.Module} **/\nexports.module = angular.module('app', [\n  'gettext',\n  ngeoMapModule.name,\n  ngeoMiscDebounce.name,\n  ngeoStatemanagerModule.name,\n]);\n\n/**\n * An application-specific map component that updates the URL in the browser\n * address bar when the map view changes. It also sets the initial view based\n * on the URL query params at init time.\n *\n * This component gets a reference to the map instance through the \"app-map\"\n * attribute.\n *\n * @type {!angular.Component}\n */\nexports.mapComponent = {\n  controller: 'AppMapController as ctrl',\n  bindings: {\n    'map': '=appMap'\n  },\n  template: '<div ngeo-map=ctrl.map></div>'\n};\n\n\nexports.module.component('appMap', exports.mapComponent);\n\n\n/**\n * @param {ngeo.statemanager.Location} ngeoLocation ngeo Location service.\n * @param {ngeox.miscDebounce} ngeoDebounce ngeo Debounce factory.\n * @constructor\n * @ngInject\n */\nexports.MapComponentController = function(ngeoLocation, ngeoDebounce) {\n  /**\n   * @type {ol.Map}\n   * @export\n   */\n  this.map;\n\n  /**\n   * @type {ngeo.statemanager.Location}\n   * @private\n   */\n  this.ngeoLocation_ = ngeoLocation;\n\n  /**\n   * @type {ngeox.miscDebounce}\n   * @private\n   */\n  this.ngeoDebounce_ = ngeoDebounce;\n};\n\nexports.module.controller('AppMapController', exports.MapComponentController);\n\nexports.MapComponentController.prototype.$onInit = function() {\n  const view = this.map.getView();\n\n  let zoom = this.ngeoLocation_.getParam('z');\n  zoom = zoom !== undefined ? +zoom : 4;\n\n  const x = this.ngeoLocation_.getParam('x');\n  const y = this.ngeoLocation_.getParam('y');\n  const center = (x !== undefined) && (y !== undefined) ?\n    [+x, +y] : [0, 0];\n\n  view.setCenter(center);\n  view.setZoom(zoom);\n\n  this.ngeoLocation_.updateParams({\n    'z': zoom,\n    'x': Math.round(center[0]),\n    'y': Math.round(center[1])\n  });\n\n  view.on('propertychange',\n    this.ngeoDebounce_(\n      /**\n       * @param {ol.Object.Event} e Object event.\n       */\n      (e) => {\n        const center = view.getCenter();\n        const params = {\n          'z': view.getZoom(),\n          'x': Math.round(center[0]),\n          'y': Math.round(center[1])\n        };\n        this.ngeoLocation_.updateParams(params);\n      }, 300, /* invokeApply */ true));\n};\n\n/**\n * A draw component that adds a simple draw tool.\n *\n * @type {!angular.Component}\n */\nexports.drawComponent = {\n  controller: 'AppDrawController as ctrl',\n  bindings: {\n    'map': '=appDrawMap',\n    'layer': '=appDrawLayer'\n  },\n  template:\n      '<label>Enable drawing:' +\n      '<input type=\"checkbox\" ng-model=\"ctrl.interaction.active\" />' +\n      '</label><br>' +\n      '<button ng-click=\"ctrl.clearLayer()\">Clear layer</button>'\n};\n\n\nexports.module.component('appDraw', exports.drawComponent);\n\n\n/**\n * @param {!angular.Scope} $scope Scope.\n * @param {!ngeo.statemanager.Location} ngeoLocation ngeo Location service.\n * @constructor\n * @export\n * @ngInject\n */\nexports.DrawComponentController = function($scope, ngeoLocation) {\n\n  /**\n   * @type {ol.Map}\n   * @export\n   */\n  this.map;\n\n  /**\n   * @type {ol.layer.Vector}\n   */\n  this.layer;\n\n  /**\n   * @type {!ngeo.statemanager.Location}\n   * @private\n   */\n  this.ngeoLocation_ = ngeoLocation;\n\n  /**\n   * @type {!angular.Scope}\n   * @private\n   */\n  this.scope_ = $scope;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.featureSeq_ = 0;\n\n  /**\n   * @type {ol.interaction.Draw}\n   * @export\n   */\n  this.interaction;\n};\n\nexports.DrawComponentController.prototype.$onInit = function() {\n  const vectorSource = this.layer.getSource();\n\n  this.interaction = new olInteractionDraw({\n    type: /** @type {ol.geom.GeometryType} */ ('LineString'),\n    source: vectorSource\n  });\n\n  this.interaction.setActive(false);\n  this.map.addInteraction(this.interaction);\n  ngeoMiscDecorate.interaction(this.interaction);\n\n  this.interaction.on('drawend', function(e) {\n    e.feature.set('id', ++this.featureSeq_);\n  }, this);\n\n  // Deal with the encoding and decoding of features in the URL.\n\n  const fhFormat = new ngeoFormatFeatureHash();\n\n  vectorSource.on('addfeature', (e) => {\n    const feature = e.feature;\n    feature.setStyle(new olStyleStyle({\n      stroke: new olStyleStroke({\n        color: [255, 0, 0, 1],\n        width: 2\n      })\n    }));\n    const features = vectorSource.getFeatures();\n    const encodedFeatures = fhFormat.writeFeatures(features);\n    this.scope_.$applyAsync(() => {\n      this.ngeoLocation_.updateParams({'features': encodedFeatures});\n    });\n  });\n\n  const encodedFeatures = this.ngeoLocation_.getParam('features');\n  if (encodedFeatures !== undefined) {\n    const features = fhFormat.readFeatures(encodedFeatures);\n    this.featureSeq_ = features.length;\n    vectorSource.addFeatures(features);\n  }\n};\n\n\n/**\n * Clear the vector layer.\n * @export\n */\nexports.DrawComponentController.prototype.clearLayer = function() {\n  this.layer.getSource().clear(true);\n  this.featureSeq_ = 0;\n  this.ngeoLocation_.deleteParam('features');\n};\n\nexports.module.controller('AppDrawController', exports.DrawComponentController);\n\n\n/**\n * @constructor\n */\nexports.MainController = function() {\n\n  /**\n   * @type {ol.Map}\n   * @export\n   */\n  this.map = new olMap({\n    layers: [\n      new olLayerTile({\n        source: new olSourceOSM()\n      })\n    ]\n  });\n\n\n  const vectorSource = new olSourceVector();\n\n  /**\n   * @type {ol.layer.Vector}\n   * @export\n   */\n  this.vectorLayer = new olLayerVector({\n    source: vectorSource\n  });\n\n  // Use vectorLayer.setMap(map) rather than map.addLayer(vectorLayer). This\n  // makes the vector layer \"unmanaged\", meaning that it is always on top.\n  this.vectorLayer.setMap(this.map);\n\n};\n\n\nexports.module.controller('MainController', exports.MainController);\n\n\nexport default exports;\n"],"sourceRoot":""}